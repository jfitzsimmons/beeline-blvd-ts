local world = require "main.states.worldstate"
local utils = require "main.utils.utils"
local chest = require "main.systems.inventorysystem"

function init(self)
	self.actorinventory = {}
	self.watcher = ""
end

local function add_item_player(item)
	world.player.inventory[#world.player.inventory+1]=item
	chest.add_chest_bonus(world.player, item)
end

local function remove_item_player(item)
	local index = utils.get_index(world.player.inventory,item)
	table.remove(world.player.inventory, index)
	chest.remove_chest_bonus(world.player, item)
end

function add_item_actor(actor, room, inv_item) 
	if world.npcs.all[actor] ~= nil then
		world.npcs.all[actor].inventory[#world.npcs.all[actor].inventory+1]=inv_item
		chest.add_chest_bonus(world.npcs.all[actor], inv_item)
	else
		world.rooms.all[room].actors[actor].inventory[#world.rooms.all[room].actors[actor].inventory+1]=inv_item
	end	
end

local function remove_item_actor(actor, room, inv_item)
	if world.npcs.all[actor] ~= nil then
		local index =utils.get_index(world.npcs.all[actor].inventory, inv_item)
		table.remove(world.npcs.all[actor].inventory, index)
		chest.remove_chest_bonus(world.npcs.all[actor], inv_item)
	else
		local index =utils.get_index(world.rooms.all[room].actors[actor].inventory, inv_item)
		table.remove(world.rooms.all[room].actors[actor].inventory, index)
	end	
end

local function hide_inventory_animation(node,action) 
	gui.animate(node, gui.PROP_COLOR, vmath.vector4(1, 1, 1, 0), gui.EASING_OUTQUAD, 0.2)
	timer.delay(0.3, false, function()
		gui.play_flipbook(node, "empty")
		gui.animate(node, gui.PROP_COLOR, vmath.vector4(1, 1, 1, 1), gui.EASING_OUTQUAD, 0.2)
	end)
end

local function show_inventory_animation(actor_inv,beneficiary) 
	local endnode = {}
	if beneficiary == "npc" then
		endnode = gui.get_node("slotb" .. (#actor_inv))
	else
		endnode = gui.get_node("slot" .. (#world.player.inventory))
	end
	gui.set_color(endnode,vmath.vector4(1, 1, 1, 0))	
	timer.delay(0.3, false, function()
		gui.animate(endnode, gui.PROP_COLOR, vmath.vector4(1, 1, 1, 1), gui.EASING_INQUAD, 0.2) 
	end)
end

local function show_icons(inventory, prefix)
	local endnode = gui.get_node(prefix .. (#inventory + 1))
	gui.play_flipbook(endnode, "empty")
	for _, item in ipairs(inventory) do
		local node = gui.get_node(prefix .. (_))
		gui.set_texture(node, "chestitems")
		gui.play_flipbook(node, item)
	end
end

local function load_inventory_sprites(actor_inv,actor)
	if actor == nil or actor == "player" then
		show_icons(world.player.inventory,"slot")
	end
	if actor == nil or actor == "npc" then
		show_icons(actor_inv, "slotb")
	end
	if actor ~= nil then
		show_inventory_animation(actor_inv,actor)
	end
end

local function choose_inventory(self)
	if self.character == true then
		return world.npcs.all[self.actorname].inventory
	else
		return world.rooms.all[self.room].actors[self.actorname].inventory
	end
end

local function check_inventory_nodes(self, action) 
	for i=1, 30 do
		local slotnum = i
		local slotname = "slot" 
		local beneficiary = "npc"
		local debtor = "player"
		if i > 20 then 
			slotnum = i -20
			slotname = slotname .. "b"
			beneficiary = "player"
			debtor = "npc"
		end
		slotname = slotname .. slotnum

		local node = gui.get_node(slotname)
		local texture = gui.get_flipbook(node)

		if gui.pick_node(node, action.x, action.y) and texture ~=hash("empty") then 
			hide_inventory_animation(node,action)

			if i < 21 then
				remove_item_player(texture)
				add_item_actor(self.actorname,self.room, texture)
			else
				remove_item_actor(self.actorname,self.room, texture)
				add_item_player(texture)
			end
			local inventory = choose_inventory(self)
			load_inventory_sprites(inventory,beneficiary)
			timer.delay(0.3, false, function()
				if debtor == "player" then
					show_icons(world.player.inventory,"slot")
				else 
					show_icons(inventory, "slotb")
				end
			end)
			break
		end
	end
end

local function reset_prop_gui()
	for i=1, 10 do
		slotname = "slotb" .. i
		local node = gui.get_node(slotname)
		gui.play_flipbook(node, "empty")
	end
end

local function reset_nodes()
	reset_prop_gui()
	for i=1, 20 do
		slotname = "slot" .. i
		local node = gui.get_node(slotname)
		gui.play_flipbook(node, "empty")
	end
end

local function exit_inventory(self)
	gui.set_enabled(gui.get_node("btm"),false)

	if self.character == true then
		world.npcs.all[self.actorname].inventory = self.actorinventory
	else
		world.rooms.all[self.room].actors[self.actorname].inventory = self.actorinventory
	end

	reset_nodes()
	msg.post("inventories#inventory", "release_input_focus")
	msg.post("level#level", "exit_gui")
end

function on_message(self, message_id, message, sender)
	if message_id == hash("opened_chest") then
		local inventory_node = gui.get_node("btm")
		local name_node = gui.get_node("propname")
		
		self.room = message.room
		self.watcher = message.watcher
		self.actorname = message.actorname --npc or prop name
		if world.npcs.all[self.actorname] ~= nil then
			self.character = true 
		else
			self.character = false
		end   --boolean to update either npc or room state
		self.actorinventory = choose_inventory(self)

		load_inventory_sprites(self.actorinventory)
		
		--show actor inventory?
		if message.action ~= "give" then
			gui.set_enabled(gui.get_node("propinventory"), true)
		else
			gui.set_enabled(gui.get_node("propinventory"), false)
		end
		gui.set_text(name_node, self.actorname)
		gui.set_enabled(inventory_node, true)
		msg.post("inventories#inventory", "acquire_input_focus")
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.released then
		if gui.pick_node(gui.get_node("exit"), action.x, action.y) then 
			exit_inventory(self)
		else
			check_inventory_nodes(self, action)
			
			-- only choose one inventory item?
			if self.watcher ~= "" and self.watcher ~= nil then
				msg.post("inventories#inventory", "release_input_focus")
				timer.delay(0.9, false, function() exit_inventory(self) end) 
			end
		end
	end
end

local world = require "main.states.worldstate"
local task = require "main.states.taskstates"
local ai = require "main.systems.ai.ai_main"
local novel = require "main.utils.novel"

local player = world.player
local npcs = world.npcs.all
local rooms = world.rooms

function init(self)
	self.npcname = nil
	self.clones = {}
	self.watcher = ""
	self.station = ""
	self.consequence = {
		confront = false,
		type = "neutral"
	}
end

local function set_interactions(actions, pos)
	local clones = {}
	local spacing = 25
	local nodepos = pos
	for k, actor in pairs(actions) do
		for i, action in ipairs(actor) do
			nodepos.y = nodepos.y + spacing
			local node = gui.get_node(action)
			local clonetree = gui.clone_tree(node)

			for ck, cv in pairs(clonetree) do
				local clone = gui.clone(cv)
				if pos then gui.set_position(clone, nodepos) end
				gui.set_visible(clone, true)

				local cloneparent = {
					clone = clone,
					actor = k,
					action = action
				}
				table.insert(clones, cloneparent)
			end
		end
		nodepos.y = nodepos.y + spacing * 1.3
		nodepos.x = nodepos.x - 25
		local node = gui.get_node("_text_label")
		gui.set_text(node, k)
		node = gui.get_node("label")
		local clonetree = gui.clone_tree(node)
		for ck, cv in pairs(clonetree) do
			local clone = gui.clone(cv)
			if pos then gui.set_position(clone, nodepos) end
			gui.set_visible(clone, true)

			local cloneparent = {
				clone = clone,
				actor = "label",
				action = k
			}
			table.insert(clones, cloneparent)
		end
		nodepos.y = nodepos.y + spacing * 0.5
	end
	return clones
end


function on_message(self, message_id, message, sender)
	if message_id == hash("shownode") then
		--populate text nodes and show them
		print("show node?")

		self.clones = set_interactions(message.actions, message.pos) --GO.pos cannot come from gui script
		self.room = message.room
		print("message.room", message.room)
		print("self.room", self.room)

		self.script = message.script
		self.npcname = message.npcname
		if npcs[self.npcname] ~= nil then
			self.is_npc = true
		else
			self.is_npc = false
		end
	elseif message_id == hash("reload_script") and self.npcname ~= nil then
		local station = world.npcs.all[self.npcname].currentstation
		self.script = novel.script_builder(self.npcname, self.room, station, nil, false)
	elseif message_id == hash("hidenode") then
		for _, clone in ipairs(self.clones) do
			gui.delete_node(clone.clone)
		end
		self.clones = {}
		self.watcher = ""
	elseif message_id == hash("updatenode") then
		local node = gui.get_node(self.selectedGui)
		if message.position then gui.set_position(node, message.position) end
	elseif message_id == hash("testjpf") then
		print("testjpf msg?")
	end
end

local function check_nodes(self, action)
	for _, c in ipairs(self.clones) do
		if gui.get_layer(c.clone) ~= hash("unclickable") and gui.pick_node(c.clone, action.x, action.y) then
			if c.action == "open" or c.action == "trade" or c.action == "give" or c.action == "pockets" then
				open_inventory(self, c.actor, c.action)
			elseif c.action == "talk" then
				open_novel(self)
			elseif c.action == "use" then
				show_ai_screen(self)
			end
		end
	end
end

local function show_ai_screen(self)
	msg.post("ai_screen#ai_screen", "show_screen")
	msg.post("#", "release_input_focus")
end

function open_novel(self)
	print("OPEN NOVEL", self.npcname)
	npcs[self.npcname].convos = npcs[self.npcname].convos + 1
	local params = {
		path = self.script,
		npc = self.npcname
	}
	print("self.script", self.script)
	print("npcs[self.npcname].convos FIRED TESTJPF OLD?!?!?!", npcs[self.npcname].convos)

	--pass params to level to access level information
	msg.post("level#level", "show_scene", params)
	msg.post("#", "release_input_focus")
end

function open_inventory(self, actor, action)
	if action == "open" then
		-- station where the watcher will be located
		self.station = rooms.all[self.room].actors[actor].watcher
		-- the actual npc assigned to that station
		self.watcher = rooms.all[self.room].stations[self.station]
	elseif action == "trade" or action == "give" or action == "pockets" then
		-- testjpf trade will need "acceptanace"???
		self.watcher = actor
	end
	if self.watcher ~= "" and self.watcher ~= nil then
		print("open_inventory task.npc_has_caution:::")
		local prev_caution = task.npc_has_caution(self.watcher, "player")

		if prev_caution ~= nil then
			self.consequence = { confront = true, type = "offender" }
		elseif action == "pockets" or action == "open" then
			self.consequence = ai.witness(self.watcher)
		elseif action == "trade" then
			self.consequence = { confront = true, type = "trade" }
		else
			self.consequence = { confront = false, type = "neutral" }
		end
	end
	if self.consequence.confront == true then
		print("Confront!!!")
		if self.is_npc == false then self.npcname = self.watcher end
		self.script = novel.script_builder(self.npcname, nil, nil, self.consequence.type, false)
		open_novel(self)
	else
		local params = {
			actorname = actor,
			is_npc = self.is_npc,
			room = self.room,
			watcher = self.watcher,
			action = action
		}
		msg.post("inventories#inventory", "opened_chest", params)
		msg.post("#", "release_input_focus")
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.released then
		check_nodes(self, action)
	end
end

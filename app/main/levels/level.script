local world = require "main.states.worldstate"
local ai = require "main.systems.ai.ai_main" 
local task = require "main.states.taskstates"
local rooms = require "main.states.roomstates"
local tasksystem = require "main.systems.tasksystem"
local quest = require "main.systems.quests.quest_main"
local novel = require "main.utils.novel"

local function game_turn(room)
	rooms.clear_room_stations()
	ai.ai_turn(room)
	quest.address_quests("turn")
	world.player.ap = world.player.ap - 1
	world.player.turns = world.player.turns + 1
end

local function update_hud()
	label.set_text("hud#time", tostring(world.clock) .. ":00")
	msg.post("hud#map", "update_heat")
	--sprite.play_flipbook("/hud#security_alert", 'alert_' .. tostring(world.player.alert_level))
	--msg.post("hud#map", "acquire_input_focus")
end

local function confrontation_scene(room, c)
	world.npcs.all[c.npc].convos = world.npcs.all[c.npc].convos + 1
	local params = {
		path = novel.script_builder(c.npc, nil, nil, c.state, false),
		npc = c.npc,
		reason = c.reason
	}
	--pass params to load novel
	msg.post("#", "show_scene", params) 
end

function on_message(self, message_id, message, sender)
	if message_id == hash("room_load") then
		if world.player.ap <= 0 then
			local params = {
				enter_room = quest.checkpoints[world.player.checkpoint:sub(1, -2)].spawn
			}
			msg.post("proxies:/controller#worldcontroller", "faint", params)
		else
			self.roomname =  message.roomname
			
			world.player.exitroom = rooms.layout[world.player.matrix.y][world.player.matrix.x]
			world.player.currentroom = self.roomname
			world.player.matrix = world.rooms.all[self.roomname].matrix
			
			if message.load_type ~= "load game" and  message.load_type ~= "return to game" and message.load_type ~= "new game" then
				game_turn(message.roomname)
			end

			update_hud()

			--testjpf so could have load npcs, then load props
			--for rk,rv in pairs(world.rooms.all[self.room].npcs) do 
			-- desks use different scripts!!
			--props use specific animations per level!!
			--hold off for a while
			--load room specific state
			msg.post("level#" .. self.roomname, "room_load")

			local confrontation = tasksystem.address_cautions()
			if confrontation ~= nil then confrontation_scene(self.roomname, confrontation) end

			--position player on screen
			msg.post("adam#adam", "wake_up")
		end
	elseif message_id == hash("exit_gui") then
		quest.address_quests("interact")
		if message.novel == true then
			msg.post( self.roomname .. ":/adam#interact", "reload_script")
		end
		msg.post( self.roomname .. ":/adam#adam", "acquire_input_focus")
	elseif message_id == hash("show_scene") then
		msg.post("hud#map", "release_input_focus")
		local params = message
		params.roomname = self.roomname
		msg.post("proxies:/controller#novelcontroller", "show_scene", params) 
	elseif message_id == hash("update_alert") then
		sprite.play_flipbook("hud#security_alert", 'alert_' .. tostring(world.player.alert_level))
		if task.plan_on_snitching(message.npc_name, "player") == false then
			task.caution_builder(
				world.npcs.all[message.npc_name], 
				"snitch", 
				"player",
				"harassing"
			)
		end
	end
end